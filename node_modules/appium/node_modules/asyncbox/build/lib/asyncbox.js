"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sleep = sleep;
exports.retry = retry;
exports.nodeify = nodeify;
exports.nodeifyAll = nodeifyAll;
exports.retryInterval = retryInterval;
exports.asyncify = asyncify;
exports.parallel = parallel;
exports.asyncmap = asyncmap;
exports.asyncfilter = asyncfilter;
exports.waitForCondition = waitForCondition;
exports.longSleep = longSleep;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _es6Mapify = require("es6-mapify");

var _lodash = _interopRequireDefault(require("lodash"));

const LONG_SLEEP_THRESHOLD = 5000;

async function sleep(ms) {
  return await _bluebird.default.delay(ms);
}

async function longSleep(ms, {
  thresholdMs = LONG_SLEEP_THRESHOLD,
  intervalMs = 1000,
  progressCb = null
} = {}) {
  if (ms < thresholdMs) {
    return await sleep(ms);
  }

  const endAt = Date.now() + ms;
  let timeLeft;
  let elapsedMs = 0;

  do {
    const pre = Date.now();
    await sleep(intervalMs);
    const post = Date.now();
    timeLeft = endAt - post;
    elapsedMs = elapsedMs + (post - pre);

    if (_lodash.default.isFunction(progressCb)) {
      progressCb({
        elapsedMs,
        timeLeft,
        progress: elapsedMs / ms
      });
    }
  } while (timeLeft > 0);
}

async function retry(times, fn, ...args) {
  let tries = 0;
  let done = false;
  let res = null;

  while (!done && tries < times) {
    tries++;

    try {
      res = await fn(...args);
      done = true;
    } catch (err) {
      if (tries >= times) {
        throw err;
      }
    }
  }

  return res;
}

async function retryInterval(times, sleepMs, fn, ...args) {
  let count = 0;

  let wrapped = async () => {
    count++;
    let res;

    try {
      res = await fn(...args);
    } catch (e) {
      if (count !== times) {
        await sleep(sleepMs);
      }

      throw e;
    }

    return res;
  };

  return await retry(times, wrapped);
}

async function parallel(promises) {
  return await _bluebird.default.all(promises);
}

function nodeify(promisey, cb) {
  return _bluebird.default.resolve(promisey).nodeify(cb);
}

function nodeifyAll(promiseyMap) {
  let cbMap = {};

  for (const [name, fn] of (0, _es6Mapify.mapify)(promiseyMap)) {
    cbMap[name] = function (...args) {
      const _cb = args.slice(-1)[0];
      args = args.slice(0, -1);
      nodeify(fn(...args), _cb);
    };
  }

  return cbMap;
}

function asyncify(fn, ...args) {
  _bluebird.default.resolve(fn(...args)).done();
}

async function asyncmap(coll, mapper, runInParallel = true) {
  if (runInParallel) {
    return parallel(coll.map(mapper));
  }

  let newColl = [];

  for (let item of coll) {
    newColl.push((await mapper(item)));
  }

  return newColl;
}

async function asyncfilter(coll, filter, runInParallel = true) {
  let newColl = [];

  if (runInParallel) {
    let bools = await parallel(coll.map(filter));

    for (let i = 0; i < coll.length; i++) {
      if (bools[i]) {
        newColl.push(coll[i]);
      }
    }
  } else {
    for (let item of coll) {
      if (await filter(item)) {
        newColl.push(item);
      }
    }
  }

  return newColl;
}

async function waitForCondition(condFn, opts = {}) {
  _lodash.default.defaults(opts, {
    waitMs: 5000,
    intervalMs: 500
  });

  const debug = opts.logger ? opts.logger.debug.bind(opts.logger) : _lodash.default.noop;
  const error = opts.error;
  const begunAt = Date.now();
  const endAt = begunAt + opts.waitMs;

  const spin = async function spin() {
    const result = await condFn();

    if (result) {
      return result;
    }

    const now = Date.now();
    const waited = now - begunAt;

    if (now < endAt) {
      debug(`Waited for ${waited} ms so far`);
      await _bluebird.default.delay(opts.intervalMs);
      return await spin();
    }

    throw error ? _lodash.default.isString(error) ? new Error(error) : error : new Error(`Condition unmet after ${waited} ms. Timing out.`);
  };

  return await spin();
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9hc3luY2JveC5qcyJdLCJuYW1lcyI6WyJMT05HX1NMRUVQX1RIUkVTSE9MRCIsInNsZWVwIiwibXMiLCJCIiwiZGVsYXkiLCJsb25nU2xlZXAiLCJ0aHJlc2hvbGRNcyIsImludGVydmFsTXMiLCJwcm9ncmVzc0NiIiwiZW5kQXQiLCJEYXRlIiwibm93IiwidGltZUxlZnQiLCJlbGFwc2VkTXMiLCJwcmUiLCJwb3N0IiwiXyIsImlzRnVuY3Rpb24iLCJwcm9ncmVzcyIsInJldHJ5IiwidGltZXMiLCJmbiIsImFyZ3MiLCJ0cmllcyIsImRvbmUiLCJyZXMiLCJlcnIiLCJyZXRyeUludGVydmFsIiwic2xlZXBNcyIsImNvdW50Iiwid3JhcHBlZCIsImUiLCJwYXJhbGxlbCIsInByb21pc2VzIiwiYWxsIiwibm9kZWlmeSIsInByb21pc2V5IiwiY2IiLCJyZXNvbHZlIiwibm9kZWlmeUFsbCIsInByb21pc2V5TWFwIiwiY2JNYXAiLCJuYW1lIiwiX2NiIiwic2xpY2UiLCJhc3luY2lmeSIsImFzeW5jbWFwIiwiY29sbCIsIm1hcHBlciIsInJ1bkluUGFyYWxsZWwiLCJtYXAiLCJuZXdDb2xsIiwiaXRlbSIsInB1c2giLCJhc3luY2ZpbHRlciIsImZpbHRlciIsImJvb2xzIiwiaSIsImxlbmd0aCIsIndhaXRGb3JDb25kaXRpb24iLCJjb25kRm4iLCJvcHRzIiwiZGVmYXVsdHMiLCJ3YWl0TXMiLCJkZWJ1ZyIsImxvZ2dlciIsImJpbmQiLCJub29wIiwiZXJyb3IiLCJiZWd1bkF0Iiwic3BpbiIsInJlc3VsdCIsIndhaXRlZCIsImlzU3RyaW5nIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLG9CQUFvQixHQUFHLElBQTdCOztBQUVBLGVBQWVDLEtBQWYsQ0FBc0JDLEVBQXRCLEVBQTBCO0FBQ3hCLFNBQU8sTUFBTUMsa0JBQUVDLEtBQUYsQ0FBUUYsRUFBUixDQUFiO0FB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TyxLQUFuQjtBQUNBLFFBQU1DLE9BQU8sR0FBRzNELElBQUksQ0FBQ0MsR0FBTCxFQUFoQjtBQUNBLFFBQU1GLEtBQUssR0FBRzRELE9BQU8sR0FBR1IsSUFBSSxDQUFDRSxNQUE3Qjs7QUFDQSxRQUFNTyxJQUFJLEdBQUcsZUFBZUEsSUFBZixHQUF1QjtBQUNsQyxVQUFNQyxNQUFNLEdBQUcsTUFBTVgsTUFBTSxFQUEzQjs7QUFDQSxRQUFJVyxNQUFKLEVBQVk7QUFDVixhQUFPQSxNQUFQO0FBQ0Q7O0FBQ0QsVUFBTTVELEdBQUcsR0FBR0QsSUFBSSxDQUFDQyxHQUFMLEVBQVo7QUFDQSxVQUFNNkQsTUFBTSxHQUFHN0QsR0FBRyxHQUFHMEQsT0FBckI7O0FBQ0EsUUFBSTFELEdBQUcsR0FBR0YsS0FBVixFQUFpQjtBQUNmdUQsTUFBQUEsS0FBSyxDQUFFLGNBQWFRLE1BQU8sWUFBdEIsQ0FBTDtBQUNBLFlBQU1yRSxrQkFBRUMsS0FBRixDQUFReUQsSUFBSSxDQUFDdEQsVUFBYixDQUFOO0FBQ0EsYUFBTyxNQUFNK0QsSUFBSSxFQUFqQjtBQUNEOztBQUVELFVBQU1GLEtBQUssR0FDTnBELGdCQUFFeUQsUUFBRixDQUFXTCxLQUFYLElBQW9CLElBQUlNLEtBQUosQ0FBVU4sS0FBVixDQUFwQixHQUF1Q0EsS0FEakMsR0FFUCxJQUFJTSxLQUFKLENBQVcseUJBQXdCRixNQUFPLGtCQUExQyxDQUZKO0FBR0QsR0FoQkQ7O0FBaUJBLFNBQU8sTUFBTUYsSUFBSSxFQUFqQjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNwaWxlOm1haW5cblxuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgbWFwaWZ5IH0gZnJvbSAnZXM2LW1hcGlmeSc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBMT05HX1NMRUVQX1RIUkVTSE9MRCA9IDUwMDA7IC8vIGFueXRoaW5nIG92ZXIgNTAwMG1zIHdpbGwgdHVybiBpbnRvIGEgc3BpblxuXG5hc3luYyBmdW5jdGlvbiBzbGVlcCAobXMpIHtcbiAgcmV0dXJuIGF3YWl0IEIuZGVsYXkobXMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb25nU2xlZXAgKG1zLCB7XG4gIHRocmVzaG9sZE1zID0gTE9OR19TTEVFUF9USFJFU0hPTEQsXG4gIGludGVydmFsTXMgPSAxMDAwLFxuICBwcm9ncmVzc0NiID0gbnVsbCxcbn0gPSB7fSkge1xuICBpZiAobXMgPCB0aHJlc2hvbGRNcykge1xuICAgIHJldHVybiBhd2FpdCBzbGVlcChtcyk7XG4gIH1cbiAgY29uc3QgZW5kQXQgPSBEYXRlLm5vdygpICsgbXM7XG4gIGxldCB0aW1lTGVmdDtcbiAgbGV0IGVsYXBzZWRNcyA9IDA7XG4gIGRvIHtcbiAgICBjb25zdCBwcmUgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHNsZWVwKGludGVydmFsTXMpO1xuICAgIGNvbnN0IHBvc3QgPSBEYXRlLm5vdygpO1xuICAgIHRpbWVMZWZ0ID0gZW5kQXQgLSBwb3N0O1xuICAgIGVsYXBzZWRNcyA9IGVsYXBzZWRNcyArIChwb3N0IC0gcHJlKTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHByb2dyZXNzQ2IpKSB7XG4gICAgICBwcm9ncmVzc0NiKHtlbGFwc2VkTXMsIHRpbWVMZWZ0LCBwcm9ncmVzczogZWxhcHNlZE1zIC8gbXN9KTtcbiAgICB9XG4gIH0gd2hpbGUgKHRpbWVMZWZ0ID4gMCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJldHJ5ICh0aW1lcywgZm4sIC4uLmFyZ3MpIHtcbiAgbGV0IHRyaWVzID0gMDtcbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgbGV0IHJlcyA9IG51bGw7XG4gIHdoaWxlICghZG9uZSAmJiB0cmllcyA8IHRpbWVzKSB7XG4gICAgdHJpZXMrKztcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXdhaXQgZm4oLi4uYXJncyk7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cmllcyA+PSB0aW1lcykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJldHJ5SW50ZXJ2YWwgKHRpbWVzLCBzbGVlcE1zLCBmbiwgLi4uYXJncykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgd3JhcHBlZCA9IGFzeW5jICgpID0+IHtcbiAgICBjb3VudCsrO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGF3YWl0IGZuKC4uLmFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGRvIG5vdCBwYXVzZSB3aGVuIGZpbmlzaGVkIHRoZSBsYXN0IHJldHJ5XG4gICAgICBpZiAoY291bnQgIT09IHRpbWVzKSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKHNsZWVwTXMpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmV0dXJuIGF3YWl0IHJldHJ5KHRpbWVzLCB3cmFwcGVkKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyYWxsZWwgKHByb21pc2VzKSB7XG4gIHJldHVybiBhd2FpdCBCLmFsbChwcm9taXNlcyk7XG59XG5cbmZ1bmN0aW9uIG5vZGVpZnkgKHByb21pc2V5LCBjYikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrc1xuICByZXR1cm4gQi5yZXNvbHZlKHByb21pc2V5KS5ub2RlaWZ5KGNiKTtcbn1cblxuZnVuY3Rpb24gbm9kZWlmeUFsbCAocHJvbWlzZXlNYXApIHtcbiAgbGV0IGNiTWFwID0ge307XG4gIGZvciAoY29uc3QgW25hbWUsIGZuXSBvZiBtYXBpZnkocHJvbWlzZXlNYXApKSB7XG4gICAgY2JNYXBbbmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgY29uc3QgX2NiID0gYXJncy5zbGljZSgtMSlbMF07XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgwLCAtMSk7XG4gICAgICBub2RlaWZ5KGZuKC4uLmFyZ3MpLCBfY2IpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNiTWFwO1xufVxuXG5mdW5jdGlvbiBhc3luY2lmeSAoZm4sIC4uLmFyZ3MpIHtcbiAgQi5yZXNvbHZlKGZuKC4uLmFyZ3MpKS5kb25lKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jbWFwIChjb2xsLCBtYXBwZXIsIHJ1bkluUGFyYWxsZWwgPSB0cnVlKSB7XG4gIGlmIChydW5JblBhcmFsbGVsKSB7XG4gICAgcmV0dXJuIHBhcmFsbGVsKGNvbGwubWFwKG1hcHBlcikpO1xuICB9XG5cbiAgbGV0IG5ld0NvbGwgPSBbXTtcbiAgZm9yIChsZXQgaXRlbSBvZiBjb2xsKSB7XG4gICAgbmV3Q29sbC5wdXNoKGF3YWl0IG1hcHBlcihpdGVtKSk7XG4gIH1cbiAgcmV0dXJuIG5ld0NvbGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jZmlsdGVyIChjb2xsLCBmaWx0ZXIsIHJ1bkluUGFyYWxsZWwgPSB0cnVlKSB7XG4gIGxldCBuZXdDb2xsID0gW107XG4gIGlmIChydW5JblBhcmFsbGVsKSB7XG4gICAgbGV0IGJvb2xzID0gYXdhaXQgcGFyYWxsZWwoY29sbC5tYXAoZmlsdGVyKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm9vbHNbaV0pIHtcbiAgICAgICAgbmV3Q29sbC5wdXNoKGNvbGxbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNvbGwpIHtcbiAgICAgIGlmIChhd2FpdCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgbmV3Q29sbC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3Q29sbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNvbmRpdGlvbiAoY29uZEZuLCBvcHRzID0ge30pIHtcbiAgXy5kZWZhdWx0cyhvcHRzLCB7XG4gICAgd2FpdE1zOiA1MDAwLFxuICAgIGludGVydmFsTXM6IDUwMCxcbiAgfSk7XG4gIGNvbnN0IGRlYnVnID0gb3B0cy5sb2dnZXIgPyBvcHRzLmxvZ2dlci5kZWJ1Zy5iaW5kKG9wdHMubG9nZ2VyKSA6IF8ubm9vcDtcbiAgY29uc3QgZXJyb3IgPSBvcHRzLmVycm9yO1xuICBjb25zdCBiZWd1bkF0ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgZW5kQXQgPSBiZWd1bkF0ICsgb3B0cy53YWl0TXM7XG4gIGNvbnN0IHNwaW4gPSBhc3luYyBmdW5jdGlvbiBzcGluICgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25kRm4oKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHdhaXRlZCA9IG5vdyAtIGJlZ3VuQXQ7XG4gICAgaWYgKG5vdyA8IGVuZEF0KSB7XG4gICAgICBkZWJ1ZyhgV2FpdGVkIGZvciAke3dhaXRlZH0gbXMgc28gZmFyYCk7XG4gICAgICBhd2FpdCBCLmRlbGF5KG9wdHMuaW50ZXJ2YWxNcyk7XG4gICAgICByZXR1cm4gYXdhaXQgc3BpbigpO1xuICAgIH1cbiAgICAvLyBpZiB0aGVyZSBpcyBhbiBlcnJvciBvcHRpb24sIGl0IGlzIGVpdGhlciBhIHN0cmluZyBtZXNzYWdlIG9yIGFuIGVycm9yIGl0c2VsZlxuICAgIHRocm93IGVycm9yXG4gICAgICA/IChfLmlzU3RyaW5nKGVycm9yKSA/IG5ldyBFcnJvcihlcnJvcikgOiBlcnJvcilcbiAgICAgIDogbmV3IEVycm9yKGBDb25kaXRpb24gdW5tZXQgYWZ0ZXIgJHt3YWl0ZWR9IG1zLiBUaW1pbmcgb3V0LmApO1xuICB9O1xuICByZXR1cm4gYXdhaXQgc3BpbigpO1xufVxuXG5leHBvcnQge1xuICBzbGVlcCwgcmV0cnksIG5vZGVpZnksIG5vZGVpZnlBbGwsIHJldHJ5SW50ZXJ2YWwsIGFzeW5jaWZ5LCBwYXJhbGxlbCxcbiAgYXN5bmNtYXAsIGFzeW5jZmlsdGVyLCB3YWl0Rm9yQ29uZGl0aW9uLCBsb25nU2xlZXAsXG59O1xuIl0sImZpbGUiOiJsaWIvYXN5bmNib3guanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
